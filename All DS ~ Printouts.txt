INDEX


No.
	Practical
	Date
	Sign
	1 (a)
	Perform AES Encryption
	

	

	1 (b)
	Perform RSA Encryption
	

	

	2
	Access Control Implementation using Role-Based Access Control (RBAC)
	

	

	3
	GDPR Compliance Automation Using Python
	

	

	4
	Phishing Simulation and Employee Training Automation
	

	

	5
	Implement PCI DSS Compliance
	

	

	6
	Implement Automated Data Classification and Masking
	

	

	7
	Implementing Data Security Compliance in Healthcare (HIPAA Compliance)
	

	

	8 (a)
	Study & implementation of identify & access management (IAM)
	

	

	8 (b)
	Study & implementation of Data Loss prevention (DLP)
	

	

	________________
1 - a: perform aes practical


Code:
from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes
from cryptography.hazmat.backends import default_backend
import os
import base64


def aes_encrypt(plain_text, key):
    #Generate a random 16-byte
    iv = os.urandom(16)
    cipher = Cipher(algorithms.AES(key), modes.CFB(iv), backend=default_backend())
    encryptor = cipher.encryptor()
    encrypted = encryptor.update(plain_text.encode()) + encryptor.finalize()
    return base64.b64encode(iv + encrypted).decode('utf-8')


def aes_decrypt(encrypted_text, key):
  encrypted_data = base64.b64decode(encrypted_text)
  iv = encrypted_data[:16]
  cipher = Cipher(algorithms.AES(key), modes.CFB(iv), backend=default_backend())
  decryptor = cipher.decryptor()
  decrypted = decryptor.update(encrypted_data[16:]) + decryptor.finalize()
  return decrypted.decode('utf-8')


if __name__ == "__main__":
  key = os.urandom(16) # AES key must be either 16, 24, or 32 bytes long
  plain_text = "This is a secret message."
  encrypted_text = aes_encrypt(plain_text, key)
  print(f"Encrypted: {encrypted_text}")
  decrypted_text = aes_decrypt(encrypted_text, key)
  print(f"Decrypted: {decrypted_text}")


Output:
Encrypted: eTkxHNQavj8saubQnCWnkFrcqbLzPSDVbSzSIAATQj5EDd1QL1w2wtQ=
Decrypted: This is a secret message.
________________
1- b: perform rsa practical


Code:
from Crypto.PublicKey import RSA
from Crypto.Cipher import PKCS1_OAEP
import base64


def generate_rsa_keys():
    key = RSA.generate (2048)
    private_key = key.export_key()
    public_key = key.publickey().export_key()
    return private_key, public_key


def rsa_encrypt(plain_text, public_key):
    rsa_key = RSA.import_key(public_key)
    cipher = PKCS1_OAEP.new(rsa_key)
    encrypted = cipher.encrypt(plain_text.encode())
    return base64.b64encode(encrypted).decode('utf-8')


def rsa_decrypt(encrypted_text, private_key):
    rsa_key = RSA. import_key(private_key)
    cipher = PKCS1_OAEP.new(rsa_key)
    decrypted = cipher.decrypt (base64.b64decode(encrypted_text))
    return decrypted.decode('utf-8')


if __name__ == "__main__":
    private_key, public_key = generate_rsa_keys()
    plain_text = "This is a secret message."
    encrypted_text = rsa_encrypt(plain_text, public_key)
    print(f"Encrypted: {encrypted_text}")
    decrypted_text = rsa_decrypt (encrypted_text, private_key)
    print(f"Decrypted: {decrypted_text}")


Output:
Encrypted: teu9+cE9l5mh1I+fTicE4z2JPu4xmFHcHeTOgKy5GDhcfyRaQqhlXd2E52bXkkTGuMOJC3xiw2zM8uU8Y2Hqrxs9XWeSfAY0FJ+Qoo4Nb2lv4hbGh/8A7rMTt243MHzR8tDeyAzmMcZLvE8neYb+BrZAxS8Z0nesIvpkdWH3jTOMj1FnenxYsqqYFIUZm06/t8n66aZb7+rwIWW7+6yxEtmI/yZComdbvbEsEsJ+6pp7//QP1ww/kw7YjUjcBDV5g/Wtx+P6jzOL2vPzjdxP95m75kB3yLS8Wq/zuKrRx2LGHyVkfoygVYdFVO0ze07nzQrnLxcd+sPhssYaJLMb+g==
Decrypted: This is a secret message.
________________
2 - Access Control Implementation using Role-Based Access Control (RBAC)


Code:
class Role: 
    def __init__(self, name): 
        self.name = name
        self.permissions = []
        
    def add_permission(self, permission): 
        self.permissions.append(permission) 


    def has_permission(self, permission): 
        return permission in self.permissions 


class User:
    def __init__(self, username, role):
        self.username = username
        self.role = role 


    def has_permission(self, permission): 
        return self.role.has_permission(permission) 


class Permission: 
    def __init__(self, name): 
        self.name = name 


#Define roles 
admin_role = Role("admin") 
moderator_role = Role("moderator") 
user_role = Role("user")


# Define permissions 
read_permission = Permission("read")
write_permission = Permission("write")
delete_permission = Permission("delete") 


#Assign permissions to roles
admin_role.add_permission(read_permission)
admin_role.add_permission(write_permission)
admin_role.add_permission(delete_permission)


moderator_role.add_permission(read_permission)
moderator_role.add_permission(write_permission)


user_role.add_permission(read_permission)


#Create users with roles
admin_user = User("admin", admin_role)
moderator_user = User("moderator", moderator_role)
user = User("user", user_role) 


# Test access control 
def access_control_test(user, permission):
    if user.has_permission(permission):
        print(f"{user.username} has {permission.name} permission")
    else: 
        print(f"{user.username} does not have {permission.name} permission") 


#Run tests 
access_control_test(admin_user, read_permission)
access_control_test(admin_user, write_permission)
access_control_test(admin_user, delete_permission)


access_control_test(moderator_user, read_permission)
access_control_test(moderator_user, write_permission)
access_control_test(moderator_user, delete_permission)


access_control_test(user, read_permission)
access_control_test(user, write_permission)
access_control_test(user, delete_permission)


Output:
admin has read permission
admin has write permission
admin has delete permission
moderator has read permission
moderator has write permission
moderator does not have delete permission
user has read permission
user does not have write permission
user does not have delete permission
________________
3 - GDPR Compliance Automation Using Python


Code:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import statistics
import seaborn as sns; sns.set()
import matplotlib as plt
from sklearn import datasets, linear_model
from sklearn.metrics import mean_squared_error, r2_score
from sklearn.model_selection import train_test_split
from pandas.plotting import register_matplotlib_converters


gdpr_fines = pd.read_csv("/content/gdpr_fines.csv", index_col=0)
gdpr_fines.columns


#Cleaning the columns
gdpr_fines.rename(columns={
    'Authority': 'authority',
    'Country': 'country',
    'Date': 'date', 'Fine [鈧琞': 'fine', 'Controller/Processor': 'controller/processor', 'Quoted Art.': 'quoted article', 'Type': 'type', 'Infos': 'infos'
}, inplace=True)
gdpr_fines["date"] = gdpr_fines["date"].apply(lambda x: x.replace(",",""))
gdpr_fines["fine"] = gdpr_fines["fine"].apply(lambda x: x.replace(",",""))


gdpr_fines.columns


fines = gdpr_fines['fine']
fines = fines.apply(lambda x: x.replace(",",""))
fines = fines.replace("Unknown", np.nan)
fines = pd.to_numeric(fines)


date_and_fines = gdpr_fines.groupby(["date"]).sum()
ax1 = sns.lineplot(data=date_and_fines)
ax1.set(xlabel='Date when fine was given', ylabel='A


fine_by_country = gdpr_fines["fine"].groupby(["Country"]).count()
fine_by_country.head(10)


________________


Output:
  



        fine
Country        
AUSTRIA        4
BELGIUM        2
BULGARIA        8
CZECH REPUBLIC        8
DENMARK        1
FRANCE        5
GERMANY        6
GREECE        3
HUNGARY        10
ITALY        1
________________
4 - Phishing Simulation and Employee Training Automation


Code:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.model_selection import train_test_split, cross_val_score
from sklearn.metrics import accuracy_score, f1_score, classification_report
from sklearn.metrics import confusion_matrix, ConfusionMatrixDisplay
from sklearn.decomposition import PCA
from sklearn.linear_model import LogisticRegression


df = pd.read_csv('/content/Phishing_Legitimate_full.csv')


pca = PCA(n_components=2)
pca = PCA(n_components=3)
pca_3d = pca.fit_transform(df.drop(columns='CLASS_LABEL'))
pca_df = pd.DataFrame(pca_3d, columns=['PCA1', 'PCA2', 'PCA3'])
pca_3d = pd.concat([df['CLASS_LABEL'], pca_df], axis=1)


# logistic regression without pca
X = df.drop(columns='CLASS_LABEL')
y = df['CLASS_LABEL']
model = LogisticRegression(C=6)


cv_scores = cross_val_score(model, X, y, cv=5, scoring='accuracy')


# Print cross-validation results
print(f'Cross-validation scores: {cv_scores}')
print(f'Mean cross-validation score: {np.mean(cv_scores):.2f}')


X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3 ,random_state=42)

model.fit(X_train, y_train)
y_pred = model.predict(X_test)


accuracy = accuracy_score(y_test, y_pred)
f1 = f1_score(y_test, y_pred)


print(f'Accuracy: {accuracy:.4f}')
print(f'F1 Score: {f1:.4f}')


cm = confusion_matrix(y_test, y_pred)


fig = ConfusionMatrixDisplay(confusion_matrix=cm)
fig.plot(cmap='Blues', values_format='d')
plt.title('Confusion Matrix')


# logistic regression with pca
X_pca = pca_3d.drop(columns='CLASS_LABEL')
y_pca = pca_3d['CLASS_LABEL']
cv_scores = cross_val_score(model, X_pca, y_pca, cv=5, scoring='accuracy')


# Print cross-validation results
print(f'Cross-validation scores: {cv_scores}')
print(f'Mean cross-validation score: {np.mean(cv_scores):.2f}')


X_train_pca, X_test_pca, y_train_pca, y_test_pca = train_test_split(X_pca, y_pca, test_size=0.3 ,random_state=42)


model.fit(X_train_pca, y_train_pca)
y_pred_pca = model.predict(X_test_pca)


accuracy = accuracy_score(y_test_pca, y_pred_pca)
f1 = f1_score(y_test_pca, y_pred_pca)


print(f'Accuracy on test set: {accuracy:.2f}')
print(f'F1 Score on test set: {f1:.2f}')


cm = confusion_matrix(y_test_pca, y_pred_pca)


fig = ConfusionMatrixDisplay(confusion_matrix=cm)
fig.plot(cmap='Blues', values_format='d')
plt.title('Confusion Matrix')


Output:




	Logistic with pca
	Logistic without pca
	accuracy
	0.99
	0.9923
	f1-score
	 1.00
	0.9925
	Confusion matrix
	  

	  

	

________________
5 - PCI DSS Compliance


Code:
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.model_selection import train_test_split, GridSearchCV
from sklearn.ensemble import GradientBoostingClassifier
from sklearn.metrics import (
    classification_report, confusion_matrix, roc_curve, roc_auc_score, 
    f1_score, accuracy_score, precision_score, recall_score
)


devsample = pd.read_csv("/content/drive/MyDrive/final_version.csv")
y = devsample['fraud']
X = devsample.drop(columns=['User', 'Card', 'fraud', 'datetime', 'weight', 'opendate'])
X = pd.get_dummies(X, drop_first=True)
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=35)
param_grid = {
    'learning_rate': [0.1, 0.01],
    'max_depth': [3, 15],
    'n_estimators': [100, 300],
    'min_samples_split': [10, 20]
}


gridsearch = GridSearchCV(GradientBoostingClassifier(), param_grid, scoring='f1', verbose=10, cv=2)
gridsearch.fit(X_train, y_train)


best_model = gridsearch.best_estimator_
importance_df = pd.DataFrame({
    'Feature': X_train.columns, 
    'Importance': best_model.feature_importances_
}).sort_values(by='Importance', ascending=False)


y_pred = best_model.predict(X_test)
conf_matrix = confusion_matrix(y_test, y_pred)
print("\nClassification Report:\n", classification_report(y_test, y_pred))
print("Accuracy Score:", accuracy_score(y_test, y_pred))
print("F1 Score:", f1_score(y_test, y_pred))
print("Precision Score:", precision_score(y_test, y_pred))
print("Recall Score:", recall_score(y_test, y_pred))


# Plot Confusion Matrix
plt.figure(figsize=(8, 6))
sns.heatmap(conf_matrix, annot=True, fmt='.8g', cmap='Blues', xticklabels=['Non-Fraud', 'Fraud'], yticklabels=['Non-Fraud', 'Fraud'])
plt.ylabel('Actual')
plt.xlabel('Predicted')
plt.title('Confusion Matrix')
plt.show()


# ROC Curve
y_prob = best_model.predict_proba(X_test)[:, 1]
fpr, tpr, _ = roc_curve(y_test, y_prob)
roc_auc = roc_auc_score(y_test, y_prob)


plt.figure(figsize=(10, 6))
plt.plot(fpr, tpr, color='blue', label=f'ROC Curve (AUC = {roc_auc:.2f})')
plt.plot([0, 1], [0, 1], color='red', linestyle='--')
plt.xlabel('False Positive Rate')
plt.ylabel('True Positive Rate')
plt.title('ROC Curve')
plt.legend(loc='lower right')
plt.grid()
plt.show()


Output:
Classification Report:
               precision    recall  f1-score   support


   
    accuracy                           1.00      1634
   macro avg       1.00      1.00      1.00      1634
weighted avg       1.00      1.00      1.00      1634


Accuracy Score: 1.0
F1 Score: 1.0
Precision Score: 1.0
Recall Score: 1.0        0       1.00      1.00      1.00      1345
           1       1.00      1.00      1.00       289




  

	  

	________________